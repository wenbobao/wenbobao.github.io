[{"title":"KSCrash","date":"2017-03-15T07:00:16.000Z","path":"2017/03/15/KSCrash/","text":"项目地址:https://github.com/kstenerud/KSCrash How to Use KSCrash Add the framework to your project (or add the KSCrash project as a dependency) Add the following system frameworks &amp; libraries to your project: libc++.dylib libz.dylib MessageUI.framework (iOS only) SystemConfiguration.framework Add the flag “-ObjC” to Other Linker Flags in your Build Settings Add the following to your [application: didFinishLaunchingWithOptions:] method in your app delegate: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &lt;KSCrash/KSCrash.h&gt;// Include to use the standard reporter.#import &lt;KSCrash/KSCrashInstallationStandard.h&gt;// Include to use Quincy or Hockey.#import &lt;KSCrash/KSCrashInstallationQuincyHockey.h&gt;// Include to use the email reporter.#import &lt;KSCrash/KSCrashInstallationEmail.h&gt;// Include to use Victory.#import &lt;KSCrash/KSCrashInstallationVictory.h&gt;- (BOOL)application:(UIApplication*) application didFinishLaunchingWithOptions:(NSDictionary*) launchOptions&#123;KSCrashInstallationStandard* installation = [KSCrashInstallationStandard sharedInstance];installation.url = [NSURL URLWithString:@&quot;http://put.your.url.here&quot;];// OR:KSCrashInstallationQuincy* installation = [KSCrashInstallationQuincy sharedInstance];installation.url = [NSURL URLWithString:@&quot;http://put.your.url.here&quot;];// OR:KSCrashInstallationHockey* installation = [KSCrashInstallationHockey sharedInstance];installation.appIdentifier = @&quot;PUT_YOUR_HOCKEY_APP_ID_HERE&quot;;// OR:KSCrashInstallationEmail* installation = [KSCrashInstallationEmail sharedInstance];installation.recipients = @[@&quot;some@email.address&quot;];// Optional (Email): Send Apple-style reports instead of JSON[installation setReportStyle:KSCrashEmailReportStyleApple useDefaultFilenameFormat:YES]; // Optional: Add an alert confirmation (recommended for email installation)[installation addConditionalAlertWithTitle:@&quot;Crash Detected&quot; message:@&quot;The app crashed last time it was launched. Send a crash report?&quot; yesAnswer:@&quot;Sure!&quot; noAnswer:@&quot;No thanks&quot;];// OR:KSCrashInstallationVictory* installation = [KSCrashInstallationVictory sharedInstance];installation.url = [NSURL URLWithString:@&quot;https://put.your.url.here/api/v1/crash/&lt;application key&gt;&quot;];[installation install]; …&#125;// last: [installation sendAllReportsWithCompletion:^(NSArray *filteredReports, BOOL completed, NSError *error)&#123; // Stuff to do when report sending is complete&#125;];","tags":[{"name":"KSCrash","slug":"KSCrash","permalink":"http://blog.wenbobao.cn/tags/KSCrash/"}]},{"title":"远程启动jboss,关闭窗口,jboss自动关闭","date":"2016-08-17T07:55:21.000Z","path":"2016/08/17/2016-08-17/","text":"问题描述:java环境: jdk1.6, jboss4.2远程ssh启动jboss ./run.sh -b xx.xx.xx.xx &amp;，可以正常访问关闭ssh窗口,不能访问解决方案: 先exit退出服务器,断开连接,再关闭ssh窗口. 直接用nohup启动jboss服务","tags":[{"name":"服务器 jboss","slug":"服务器-jboss","permalink":"http://blog.wenbobao.cn/tags/服务器-jboss/"}]},{"title":"iOS + Jenkins + SVN 自动化打包配置","date":"2016-04-11T08:36:20.000Z","path":"2016/04/11/Jenkins/","text":"环境 下载Jenkins.war https://jenkins.io/download/ JDK 1.80 tomcat7.0 步骤 将jenkins.war部署到tomcat中，启动tomcat 浏览器中输入 http://localhost:8080/jenkins/ 安装jenkins插件 12345671. Xcode integration: iOS专用2. Keychains and Provisioning Profiles Management3. Subversion Plug-in SVN 4. SSH Credentials Plugin （可选）5. build-name-setter：用于修改Build名称 （可选）6. description setter plugin：用于在修改Build描述信息，在描述信息中增加显示QRCode（二维码）（可选）7. Post-Build Script Plug-in：在编译完成后通过执行脚本实现一些额外功能 （可选） 系统管理 -&gt; 系统设置将 Subversion Workspace Version 设置为1.7 系统管理 -&gt; Keychains and Provisioning Profiles Management -&gt; 上传 keychain &amp; mobileprovision 123注意 :1. 这里keychain 是将p12文件直接改后缀名为keychain (a.p12 -&gt; a.keychain)2. mobileprovision 的 Provisioning Profiles Directory Path 设置为 $&#123;PROVISIONING_PROFILE&#125; 新建 -&gt; 一个自由风格的项目 -&gt; DEMO_V1.0_UAT 配置项目: General -&gt; 丢弃旧的构建 121. 保持构建的天数 -&gt; 102. 保持构建的最大个数 -&gt; 15 源码管理 -&gt; Subversion 121. Repository URL -&gt; SVN Path2. Credentials -&gt; 添加SVN账户,密码,描述 构建环境 121. Keychains and Code Signing Identities2. Mobile Provisioning Profiles 构建 -&gt; Execute shell 12345echo &apos;package&apos; | sudo -S xcode-select --switch /Applications/Xcode8.2.app/Contents/Developerunzip -o $WORKSPACE/3party/ZIP/XX.zip -d $WORKSPACE/3party/ZIP/nowtime=`date +%Y%m%d%H`/usr/libexec/PlistBuddy -c &quot;Set:CFBundleVersion $nowtime&quot; $WORKSPACE/DEMO/Info.plist/usr/libexec/PlistBuddy -c &quot;Set:CFBundleDisplayName DEMO UAT 1.0&quot; $WORKSPACE/DEMO/Info.plist 构建 -&gt; Xcode -&gt; General build setting 1234561. Target -&gt; (输入项目的Target)2. Setting -&gt; 勾选 Clean before build?3. Configuration -&gt; Release4. .ipa filename pattern -&gt; XX_IOS_$&#123;JOB_NAME&#125;_$&#123;VERSION&#125;5. Output directory -&gt; $WORKSPACE/build_outputs/$&#123;BUILD_TAG&#125;6. Manifest Plist URL -&gt; $WORKSPACE/build_outputs/$&#123;BUILD_TAG&#125; 如果项目使用cocoapods,需要配置 Advanced Xcode build options 1231. Xcode Schema File -&gt; (Schema的名字)2. SYMROOT -&gt; $&#123;WORKSPACE&#125;/build3. Xcode Workspace File -&gt; (Workspace的名字) 构建后操作 -&gt; Archive the artifacts 121. 用于存档的文件 -&gt; build_outputs/$&#123;BUILD_TAG&#125;/*.ipa,build_outputs/$&#123;BUILD_TAG&#125;/*.plist2. 高级设置 -&gt; 选择1，2，4，5 安全设置系统管理 -&gt; Configure Global Security 1231. 安全域 -&gt; 勾选（Jenkins专有用户数据库） -&gt; 允许用户注册2. 授权策略 -&gt; 勾选（项目矩阵授权策略）-&gt; 添加用户 (1. 管理员账户 全部勾选 2. 匿名用户 勾选 Read)3. 在项目配置文件中 -&gt; General -&gt; 启用项目安全 -&gt; 添加用户","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://blog.wenbobao.cn/tags/Jenkins/"}]},{"title":"给iOS应用增加3DTouch功能","date":"2016-03-11T08:58:30.000Z","path":"2016/03/11/给iOS应用增加3DTouch功能/","text":"3D Touch 的主要应用 A user can now press your Home screen icon to immediately access functionality provided by your app. 3D Touch 的三大模块 Home Screen Quick Actions peek and pop Force Properties Home Screen Quick Action使用与相关api详解 iOS9为我们提供了两种屏幕标签，分别是静态标签和动态标签。 静态标签所谓静态快捷方式，就是在应用安装前预先设置好的不能够改变的菜单项，它的设置方式是在 Info.plist 里面添加一个 UIApplicationShortcutItems 字段(系统没有提示，只能手打上去),如下图 UIApplicationShortcutItems 为数组类型，里面的每一个数组项代表快捷菜单上面的一个菜单项。 每一个菜单项都有下面几个属性。示例： 12345678910111213&lt;dict&gt; &lt;key&gt;UIApplicationShortcutItemIconType&lt;/key&gt; &lt;string&gt;UIApplicationShortcutIconTypeAudio&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemTitle&lt;/key&gt; &lt;string&gt;音乐&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemType&lt;/key&gt; &lt;string&gt;$(PRODUCT_BUNDLE_IDENTIFIER).First&lt;/string&gt; &lt;key&gt;UIApplicationShortcutItemUserInfo&lt;/key&gt; &lt;dict&gt; &lt;key&gt;firstShorcutKey1&lt;/key&gt; &lt;string&gt;firstShortcutKeyValue1&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt; （必须）UIApplicationShortcutItemType：这个选项表示这个菜单项的唯一标识。 （必须）UIApplicationShortcutItemTitle：这个选项表示菜单项显示的标题。 （可选）UIApplicationShortcutItemSubtitle：这个表示菜单项的子标题。 （可选）UIApplicationShortcutItemIconType：这个属性表示菜单的图标，系统自带的图标。 （可选）UIApplicationShortcutItemIconFile：这个属性表示菜单图标的文件名，可以使用自定义的图标。 （可选）UIApplicationShortcutItemUserInfo：这个代表了菜单项点击后，传入的用户信息，也是可选的。 效果如下: 动态标签动态标签是我们在程序中，通过代码添加的，与之相关的类，主要有三个： UIApplicationShortcutItem 创建3DTouch标签的类 UIMutableApplicationShortcutItem 创建可变的3DTouch标签的类 UIApplicationShortcutIcon 创建标签中图片Icon的类 3、响应标签的行为 类似推送，当我们点击标签进入应用程序时，也可以进行一些操作，我们可以看到，在applocation中增加了这样一个方法： ( void )application:( UIApplication )application performActionForShortcutItem:(UIApplicationShortcutItem )shortcutItem completionHandler:( void (^)( BOOLsucceeded))completionHandler NS_AVAILABLE_IOS ( 9 _0); 当我们通过标签进入app时，就会在appdelegate中调用这样一个回调，我们可以获取shortcutItem的信息进行相关逻辑操作。 这里有一点需要注意：我们在app的入口函数： ( BOOL )application:( UIApplication )application didFinishLaunchingWithOptions:( NSDictionary )launchOptions; 也需要进行一下判断，在launchOptions中有UIApplicationLaunchOptionsShortcutItemKey这样一个键，通过它，我们可以区别是否是从标签进入的app，如果是则处理结束逻辑后，返回NO，防止处理逻辑被反复回调。 几点注意： 1、快捷标签最多可以创建四个，包括静态的和动态的。 2、每个标签的题目和icon最多两行，多出的会用…省略 参考资料 苹果官方文档 iOS9 3D touch 适配开发 iOS 9 新特性之实现 3D Touch 就是 So easy iOS 3D Touch功能 在iPhone上使用3D Touch iOS9 3DTouch、ShortcutItem、Peek And Pop技术一览 iOS 3D Touch (UIApplicationShortcutItem、UIViewControllerPreviewing、UIPreviewAction) iOS 指压即达 如何集成iOS9里的3D Touch 在iOS9中使用3D Touch iOS开发之3D Touch iOS9 新特征之3D Touch实现 3D Touch iOS 3D Touch开发tableview页面内的使用 ios 3D Touch功能的实现 iOS 9 UITableView – How to “Peek and Pop” in to table cells with 3D touch? 3D Touch Peek and Pop iOS 9: An Introduction to 3D Touch","tags":[{"name":"3DTouch","slug":"3DTouch","permalink":"http://blog.wenbobao.cn/tags/3DTouch/"}]},{"title":"iOS给图片添加水印","date":"2016-03-11T02:11:29.000Z","path":"2016/03/11/iOS给图片添加水印/","text":"123456789101112131415161718192021222324+ (instancetype)waterMarkWithImageName:(NSString *)backgroundImageandMarkImageName:(NSString *)markName&#123; UIImage *bgImage = [UIImage imageNamed:backgroundImage]; UIGraphicsBeginImageContextWithOptions(bgImage.size, NO, 0.0); [bgImage drawInRect:CGRectMake(0, 0, bgImage.size.width, bgImage.size.height)]; UIImage *waterImage = [UIImage imageNamed:markName]; CGFloat scale = 0.3; CGFloat margin = 5; CGFloat waterW = waterImage.size.width * scale; CGFloat waterH = waterImage.size.height * scale; CGFloat waterX = bgImage.size.width - waterW - margin; CGFloat waterY = bgImage.size.height - waterH - margin; [waterImage drawInRect:CGRectMake(waterX, waterY, waterW, waterH)]; UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125;","tags":[]},{"title":"iOS远程推送","date":"2015-10-11T08:58:30.000Z","path":"2015/10/11/iOS远程推送/","text":"iOS中有两类消息推送方式 本地通知 远程推送 远程推送的响应这里分为两种情况 app关闭在app关闭时，通过本地通知进入app，不会触发application:didReceiveLocalNotification方法. 需要通过application: didFinishLaunchingWithOptions:方法, 判断是否由本地通知打开app app没有关闭在app没有关闭时，又分为2种情况: app在前台运行，此时会自动触发 application:didReceiveLocalNotification方法 app在后台运行，此时当用户点击通知图标时会触发application:didReceiveLocalNotification方法。 当app没有关闭(后台运行), 调用本地通知启动1234567891011121314151617181920212223// 本地通知回调函数，当应用程序在前台时调用 - (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification &#123; NSLog(@&quot;noti:%@&quot;,notification); // 这里真实需要处理交互的地方 // 获取通知所带的数据 NSString *notMess = [notification.userInfo objectForKey:@&quot;key&quot;]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;本地通知(前台)&quot; message:notMess delegate:nil cancelButtonTitle:@&quot;OK&quot; otherButtonTitles:nil]; [alert show]; // 更新显示的徽章个数 NSInteger badge = [UIApplication sharedApplication].applicationIconBadgeNumber; badge--; badge = badge &gt;= 0 ? badge : 0; [UIApplication sharedApplication].applicationIconBadgeNumber = badge; // 在不需要再推送时，可以取消推送 [HomeViewController cancelLocalNotificationWithKey:@&quot;key&quot;]; &#125; 当app关闭, 调用本地通知启动123456789101112131415161718192021- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; //app启动时,其他代码 [self otherCode]; /*本地通知方式-启动*/ //获取本地通知,如果不是本地通知方式启动, notification将为nil UILocalNotification *notification = [launchOptions objectForKey: UIApplicationLaunchOptionsLocalNotificationKey]; if (notification &amp;&amp; [notification isKindOfClass:[UILocalNotification class]]) &#123; //获取本地通知详细信息 NSDictionary *userInfo = notification.userInfo; //通过信息判断为哪条本地通知, 做出相应回应 NSString *name = [userInfo objectForKey:@&quot;name&quot;]; if ([name isEqualToString:@&quot;remindNotification&quot;]) &#123; //做出反应 [self actionCode]; &#125; &#125; return YES;&#125; 注意 iOS最多允许本地通知的数量是64个,超过限制的本地通知将被iOS忽略。 在iOS8之后，添加本地通知，需要用[UIApplication registerUserNotificationSettings:]去注册通知 参考资料 iOS-本地推送（本地通知） ios本地通知UILocalNotification以及区分谁触发了通知(转) Ios开发中UILocalNotification实现本地通知实现提醒功能","tags":[{"name":"UILocalNotification","slug":"UILocalNotification","permalink":"http://blog.wenbobao.cn/tags/UILocalNotification/"}]},{"title":"iOS项目中workspace,project,targe,scheme之间的关系","date":"2015-09-19T05:33:04.000Z","path":"2015/09/19/2015-09-19/","text":"workspace123A workspace is an Xcode document that groups projects and other documents so you can work on them together. A workspace can contain any number of Xcode projects, plus any other files you want to include. In addition to organizing all the files in each Xcode project, a workspace provides implicit and explicit relationships among the included projects and their targets. workspace可以包含多个project，同时管理不同的project之间的关系。 workspace 是以 xcworkspace 的文件形式存在。 workspace解决了原来仅有 project 的时候不同的 project 之间的引用和调用困难的问题。 使用cocopods时会生成workspace。 不同的 project 就是一个个的组件，workspace 把他们组装在一起，project 相互之间独立又有联系。（有的 project 之间可能会有依赖关系） 一个 workspace 的 多个 project共用一个编译路径。 Project1234An Xcode project is a repository for all the files, resources, and information required to build one or more software products. A project contains all the elements used to build your products and maintains the relationships between those elements. It contains one or more targets, which specify how to build products. A project defines default build settings for all the targets in the project (each target can also specify its own build settings, which override the project build settings) project里面包含了所有的源文件 project可以包含很多个Target project声明了项目默认的配置，target可以重写其配置，实现不同的配置 Target 一个target对应一个plist文件，在plist文件中可以设置项目名称，bundle ID ，版本号，资源文件等 target 和 target 之间没有关联，一个Target对应一个配置。 target和project之间有关联，target的 Build Settings 会从 project 的 Build Settings 继承一部分属性 可以在现有的target右键copy，创建新的target，创建target之后需要修改scheme的名字与之对应。 Scheme12You use Xcode schemes to specify which target, build configuration, and executable configuration is active at a given time.An Xcode scheme defines a collection of targets to build, a configuration to use when building, and a collection of tests to execute. scheme 是用来决定运行哪个target 一般就是一个 scheme 对应着一个 target 可以针对编译，运行，单元测试，动态分析，静态代码分析以及打包进行一些配置。 总结 怎么查看项目中的Targets，Build Configurations，Schemes？终端运行命令: 1xcodebuild -list 怎么创建Target? 1231. 新建项目，在现有target右键copy创建新的target2. 修改plist文件名字及其路径3. 修改scheme名字 怎么在项目中中获取当前运行的是哪个target？ 12341. 在SIT target -&gt; Build Settings -&gt; LLVM Custom Compiler Flags -&gt; Other C Flags 设置 -DTARGET_SIT2. 在UAT target -&gt; Build Settings -&gt; LLVM Custom Compiler Flags -&gt; Other C Flags 设置 -DTARGET_UAT3. 在PROD target -&gt; Build Settings -&gt; LLVM Custom Compiler Flags -&gt; Other C Flags 设置 -DTARGET_PROD4. 项目中 用下面的code 1234567#if defined (TARGET_SIT) NSLog(@&quot;target sit&quot;);#elif defined (TARGET_UAT) NSLog(@&quot;target uat&quot;);#else NSLog(@&quot;target prod&quot;);#endif 怎么在项目中中获取当前运行的是哪个build configurations？ 1231. project -&gt; Info -&gt; Configurations -&gt; add New Configurations2. project-&gt; Build Settings -&gt; LLVM Preprocessing -&gt; Preprocessor Macros -&gt; PROD -&gt; 设置为 -&gt; PROD=13. 项目中 用下面的code 1234567#if defined (PROD) NSLog(@&quot;scheme PROD&quot;);#elif defined (UAT) NSLog(@&quot;scheme uat&quot;);#else NSLog(@&quot;scheme sit&quot;);#endif 项目中有多个target,怎么写cocoapods？ 1234567891011121314151617181920def pods pod ‘AFNetworking’ endplatform :ios, ‘8.0’target &apos;DEMO_SIT&apos; do # use_frameworks! podsendtarget &apos;DEMO_UAT’ do # use_frameworks! podsendtarget &apos;DEMO_PROD’ do # use_frameworks! pods end 项目中添加了文件，运行时提示找不到文件怎么办？ 121. 删掉文件索引2. 重新加入文件，记得勾选所有的target","tags":[]},{"title":"sqlite常用命令查询","date":"2015-05-16T04:35:09.000Z","path":"2015/05/16/sqlite/","text":"创建表1234567CREATE TABLE COMPANY( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 删除表1DROP TABLE table_name; Insert 语句123INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)] VALUES (value1, value2, value3,...valueN);``` INSERT INTO TABLE_NAME VALUES (value1,value2,value3,…valueN);12## Select 语句 SELECT * FROM table_name;12```SELECT column1, column2, columnN FROM table_name; 运算符 比较运算符 == = != &lt;&gt; &gt; &lt; = &lt;= !&lt; !&gt; 逻辑运算符 AND BETWEEN EXISTS IN NOT IN LIKE GLOB NOT OR IS NULL IS IS NOT || UNIQUE Update 语句 123UPDATE table_nameSET column1 = value1, column2 = value2...., columnN = valueNWHERE [condition]; Delete 语句12DELETE FROM table_nameWHERE [condition]; 注: 使用 SQLite 的 DELETE 可以 删除全部的数据，但建议使用 DROP TABLE 命令删除整个表，然后再重新创建一遍。 Where 子句Like 子句% 代表零个、一个或多个数字_ 代表一个单一的数字或字符 Limit 子句限制了您想要从表中提取的行数 123SELECT column1, column2, columnN FROM table_nameLIMIT 6 从一个特定的偏移开始提取记录 1SELECT * FROM COMPANY LIMIT 3 OFFSET 2; Order By (排序) ASC 升序 DES 降序 1SELECT * FROM COMPANY ORDER BY NAME DESC; ##Group By(分组) SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。 注意 GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。 1SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME ORDER BY NAME DESC Having 子句HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。 1SELECT * FROM COMPANY GROUP BY name HAVING count(name) &lt; 2; Distinct 关键字SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。 1SELECT DISTINCT name FROM COMPANY; 约束 NOT NULL 约束：确保某列不能有 NULL 值。 DEFAULT 约束：当某列没有指定值时，为该列提供默认值。 UNIQUE 约束：确保某列中的所有值是不同的。 PRIMARY Key 约束：唯一标识数据库表中的各行/记录。 CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。 Joins Joins 子句用于结合两个或多个数据库中表的记录. SQL 定义了三种主要类型的连接： 交叉连接 - CROSS JOIN 内连接 - INNER JOIN 外连接 - OUTER JOIN （left,right,full） 注意 外链接只支持 left 别名表别名 123SELECT column1, column2....FROM table_name AS alias_nameWHERE [condition]; 列别名 123SELECT column_name AS alias_nameFROM table_nameWHERE [condition]; 触发器（Trigger）SQLite 的触发器是数据库的回调函数，它会自动执行/指定的数据库事件发生时调用。 SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。 SQLite 只支持 FOR EACH ROW 触发器（Trigger），没有 FOR EACH STATEMENT 触发器（Trigger）。因此，明确指定 FOR EACH ROW 是可选的。 WHEN 子句和触发器（Trigger）动作可能访问使用表单 NEW.column-name 和 OLD.column-name 的引用插入、删除或更新的行元素，其中 column-name 是从与触发器关联的表的列的名称。 如果提供 WHEN 子句，则只针对 WHEN 子句为真的指定行执行 SQL 语句。如果没有提供 WHEN 子句，则针对所有行执行 SQL 语句。 BEFORE 或 AFTER 关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。 当触发器相关联的表删除时，自动删除触发器（Trigger）。 要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用 tablename，而不是 database.tablename。 一个特殊的 SQL 函数 RAISE() 可用于触发器程序内抛出异常。 创建 触发器（Trigger） 的基本语法如下： 12345CREATE TRIGGER trigger_name [BEFORE|AFTER] event_name ON table_nameBEGIN -- Trigger logic goes here....END; 在这里，event_name 可以是在所提到的表 table_name 上的 INSERT、DELETE 和 UPDATE 数据库操作。您可以在表名后选择指定 FOR EACH ROW。 以下是在 UPDATE 操作上在表的一个或多个指定列上创建触发器（Trigger）的语法： 12345CREATE TRIGGER trigger_name [BEFORE|AFTER] UPDATE OF column_name ON table_nameBEGIN -- Trigger logic goes here....END; 实例 12345CREATE TRIGGER audit_log AFTER INSERT ON COMPANYBEGIN INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, datetime(&apos;now&apos;));END; 删除触发器 1DROP TRIGGER trigger_name; 索引单列索引 12CREATE INDEX index_nameON table_name (column_name); 唯一索引 12CREATE UNIQUE INDEX index_nameon table_name (column_name); 组合索引 12CREATE INDEX index_nameon table_name (column1, column2); 虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则： 索引不应该使用在较小的表上。 索引不应该使用在有频繁的大批量的更新或插入操作的表上。 索引不应该使用在含有大量的 NULL 值的列上。 索引不应该使用在频繁操作的列上。 Alter 命令重命名表 1ALTER TABLE COMPANY RENAME TO OLD_COMPANY; 添加列 1ALTER TABLE OLD_COMPANY ADD COLUMN SEX char(1); 事务 (Transaction)确保数据的完整性和处理数据库错误 事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID： 原子性（Atomicity）：确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。 一致性（Consistency)：确保数据库在成功提交的事务上正确地改变状态。 隔离性（Isolation）：使事务操作相互独立和透明。 持久性（Durability）：确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。 使用下面的命令来控制事务： BEGIN TRANSACTION：开始事务处理。 COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。 ROLLBACK：回滚所做的更改。 Autoincrement (自动递增)SQLite 的 AUTOINCREMENT 是一个关键字，用于表中的字段值自动递增。 关键字 AUTOINCREMENT 只能用于整型（INTEGER）字段。 1234567CREATE TABLE COMPANY( ID INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT NOT NULL, AGE INT NOT NULL, ADDRESS CHAR(50), SALARY REAL); 注入如果您的站点允许用户通过网页输入，并将输入内容插入到 SQLite 数据库中，这个时候您就面临着一个被称为 SQL 注入的安全问题 防止SQL注入 处理所有的转义字符 1SELECT * FROM users WHERE username=&apos;&#123;$name&#125;&apos; 内置函数 avg() 计算某列的平均值 1SELECT avg(salary) FROM COMPANY; sum() 一个数值列计算总和 1SELECT sum(salary) FROM COMPANY; count() 计算一个数据库表中的行数 1SELECT count(*) FROM COMPANY; max() 选择某列的最大值 1SELECT max(salary) FROM COMPANY; min() 选择某列的最小值 1SELECT min(salary) FROM COMPANY; upper() 把字符串转换为大写字母 1SELECT upper(name) FROM t_ichat_user; lower() 把字符串转换为小写字母 1SELECT lower(name) FROM t_ichat_user; length() 返回字符串的长度 1SELECT name, length(name) FROM COMPANY; 注意SQLITE 支持 重命名表 添加列 不支持 重命名列 删除列 添加约束 删除约束 数据类型NULLINTEGERREALTEXTBLOB 性能 批量更新数据使用事务 。因为每插入一条数据默认是有事务的， 显示使用事务加快速度 建立索引 (10万条数据). 优点: 加快检索速度，缺点 : 数据库物理空间增加，对增删改性能存在影响。 使用场景: 1.当某字段数据更新频率较低，查询频率较高 2. 经常同时存取多列，且每列都含有重复值可考虑建立复合 查询时返回更少的结果及更少的字段 对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 避免 where子句中对字段进行null判断，否则将导致引擎放弃使用索引而进行全表扫描。select id from t where num is null 避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。 在业务密集的SQL当中尽量不采用IN操作符，用EXISTS 方案代替。 not in -&gt; not EXISTS 避免使用* 最高效的删除重复记录 DELETE FROM EMP E WHERE E.ROWID &gt; (SELECT MIN(X.ROWID) FROM EMP X WHERE X.EMP_NO = E.EMP_NO)。","tags":[{"name":"sqlite","slug":"sqlite","permalink":"http://blog.wenbobao.cn/tags/sqlite/"}]},{"title":"cocoapods最新安装教程","date":"2015-03-11T02:11:29.000Z","path":"2015/03/11/2015-03-11/","text":"最新安装CocoaPods命令: sudo gem update –system gem -v gem sources –remove https://rubygems.org/ gem sources –add https://gems.ruby-china.org/ gem sources –remove https://ruby.taobao.org/ gem sources -l sudo gem install cocoapods pod setup CocoaPods命令: pod install –verbose –no-repo-update pod update –verbose –no-repo-update 什么是CocoaPods？当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。 CocoaPods是一个用来帮助我们管理第三方依赖库的工具。它可以解决库与库之间的依赖关系，下载库的源代码，同时通过创建一个Xcode的workspace来将这些第三方库和我们的工程连接起来，供我们开发使用。 安装ruby环境在安装CocoaPods之前，首先要在本地安装好Ruby环境。幸运的事MAC自带ruby环境。终端执行:ruby -v CocoaPods是以Ruby gem包的形式被安装的。查看gem版本gem -v 注：建议gem更新到最新版本，版本过低会影响升级gem：sudo gem update –system升级后查看gem版本 如何下载和安装CocoaPods？安装好Ruby环境后在终端执行: sudo gem install cocoapods 在终端中敲入这个命令之后，会发现半天没有任何反应。因为cocoapods.org被墙了。 我们可以用淘宝的Ruby镜像来访问cocoapods，执行下面的命令 gem sources –remove https://rubygems.org/ gem sources –add https://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看: gem sources -l 只有在终端中出现下面文字才表明你上面的命令是成功的： 这时候，你再次在终端中运行： sudo gem install cocoapods 等上十几秒钟，CocoaPods就可以安装完毕。 2016年10月更新: 由于Ruby TaoBao不在更新维护 , RubyGems镜像的管理工作以后将交由 Ruby China 负责，我们需要将RubyGems source 切换到 Ruby China。","tags":[{"name":"cocoapods","slug":"cocoapods","permalink":"http://blog.wenbobao.cn/tags/cocoapods/"}]},{"title":"线程安全的FMDatabaseQueue","date":"2015-03-11T02:11:29.000Z","path":"2015/03/11/FMDB(二)/","text":"为什么使用FMDatabaseQueue在实际的项目运行过程中，我们常常会遇到同一时刻有多个不同的线程请求数据库的访问。举个简单的例子: 假设当前线程1正在写数据库A，这时，线程2正好也要写数据库A，如果没有做线程安全处理，会造成很多数据没有如预期写入数据库。 假设当前线程1正在写数据库A，这时，线程2正好要读数据库A，如果没有做线程安全处理，会报”database is locked”错误。 FMDB是对sqlite的封装，而文件数据库sqlite在同一时刻允许多个进程/线程读，但同一时刻只允许一个线程写。在进行写操作时，数据库文件会被琐定，此时任何其他读/写操作都被阻塞，如果阻塞超过5秒钟(默认是5秒，重新编译sqlite可以修改超时时间)，就报”database is locked”错误。 如果线程使用单独的FMDatabase 实例是允许的，但是在多线程的环境下，不能多个线程共享一个FMDatabase对象，这样可能会造成数据的操作丢失，甚至引起程序的崩溃。 那么怎么做线程安全呢？使用FMDatabaseQueue。 FMDatabaseQueue可以比较有效的解决多线程下对数据库的访问,但是请注意不能在多个线程同时创建多个FMDatabaseQueue实例来操作同一个数据库。下面我们看下FMDatabaseQueue的用法和实现原理。 FMDatabaseQueue用法创建队列 1FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath]; 使用 12345678910[queue inDatabase:^(FMDatabase *db) &#123; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @1]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @2]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @3]; FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;]; while ([rs next]) &#123; … &#125;&#125;]; 支持事务 123456789101112[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @1]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @2]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @3]; if (whoopsSomethingWrongHappened) &#123; *rollback = YES; return; &#125; // etc… [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @4];&#125;]; FMDatabaseQueue实现原理FMDatabaseQueue通过内部创建一个Serial的dispatch_queue_t,来处理通过inDatabase和inTransaction传入的Blocks,会按顺序来执行它接收的Blocks。所以当我们在主线程（或者后台）调用inDatabase或者inTransaction时，代码实际上是同步的。 12345678910_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);- (void)inDatabase:(void (^)(FMDatabase *db))block &#123; //省略部分代码 dispatch_sync(_queue, ^() &#123; FMDatabase *db = [self database]; block(db); &#125; &#125;); FMDBRelease(self);&#125; FMDatabaseQueue这么设计的目的是让我们避免发生并发访问数据库的问题，因为对数据库的访问可能是随机的（在任何时候）、不同线程间（不同的网络回调等）的。内置一个Serial队列后，FMDatabaseQueue就变成线程安全了，所有的数据库访问都是同步执行，而且这比使用@synchronized或NSLock要高效得多。 特殊情况如果在后台执行大量的更新操作时，主线程又需要执行少量的数据库操作(比如查询)，那么在后台操作执行完之前，它还是需要等待，这时就会阻塞主线程。下面是一些参考意见: 如果在后台使用inDatabase来更新大批量的数据时，可以考虑使用inTransaction，因为后者的更新效率高很多，特别是更新大量操作（如1000条以上） 如果非必须一次性的、完整性的大批量数据，可以考虑使用数据拆解，将大量数据分成较多批少量的数据，再进行更新操作，这样能有效地避免长时间的阻塞 如果UI上不需要在更新数据时产生交互，可以将FMDatabaseQueue放入一个子线程中异步执行，这是一个不错的选择，反之，就需要考虑UI上的体验了，如加上一个UIActivityIndicatorView。 12345dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [self.databaseQueue inDatabase:^(FMDatabase *db) &#123; // do something ... &#125;];&#125;);","tags":[{"name":"FMDB","slug":"FMDB","permalink":"http://blog.wenbobao.cn/tags/FMDB/"}]},{"title":"记录下Xcode好用的插件","date":"2015-02-07T08:58:30.000Z","path":"2015/02/07/2015-02-07/","text":"Auto-Importer-for-Xcode-master github地址: https://github.com/lucholaf/Auto-Importer-for-Xcode ClangFormat-Xcode-master github地址: https://github.com/travisjeffery/ClangFormat-Xcode ColorSense-for-Xcode-master github地址: https://github.com/omz/ColorSense-for-Xcode deriveddata-exterminator-master github地址: https://github.com/kattrali/deriveddata-exterminator KSImageNamed-Xcode-master github地址https://github.com/ksuther/KSImageNamed-Xcode ObjectGraph-Xcode-master github地址https://github.com/vampirewalk/ObjectGraph-Xcode RSImageOptimPlugin-master github地址https://github.com/yeahdongcn/RSImageOptimPlugin SCXcodeSwitchExpander-master github地址https://github.com/stefanceriu/SCXcodeSwitchExpander VVDocumenter-Xcode-master github地址https://github.com/onevcat/VVDocumenter-Xcode xcodeTheme-master github地址https://github.com/laughmaker/xcodeTheme XToDo-master github地址https://github.com/trawor/XToDo ZLCheckFilePlugin-Xcode-master github地址https://github.com/MakeZL/ZLCheckFilePlugin-Xcode ZLGotoSandboxPlugin-master github地址https://github.com/MakeZL/ZLGotoSandboxPlugin 网络不好的童鞋可以去下面这个地址下载： http://pan.baidu.com/s/1dDrjcg5","tags":[{"name":"Xcode插件","slug":"Xcode插件","permalink":"http://blog.wenbobao.cn/tags/Xcode插件/"}]},{"title":"Xcode6为什么删掉pch文件","date":"2014-09-15T07:00:21.000Z","path":"2014/09/15/Xcode6为什么删掉pch/","text":"为什么xcode6没有自动创建pch文件从xcode6之后，创建新项目，没有自动创建pch文件。stackoverflow上搜索了一下:Why isn’t ProjectName-Prefix.pch created automatically in Xcode 6? 概括如下: pch会增加编译时间 pch放的是全局都使用的code, 大量代码放入pch中会影响代码重用。 把头文件引入到需要它的类中。 怎么添加pch12341. xcode - &gt; File - &gt; new PCH文件 2. 点击工程名称 — &gt; Build Settings — &gt; Prefix Header — &gt; 加入 $(SRCROOT)/$(PROJECT)/PrefixHeader.pch3. Build Settings — &gt; Precompile Prefix Header — &gt; 设置为 YES4. clean &amp; build project 最后需要在pch文件中加入 1234#ifdef __OBJC__ #import &lt;UIKit/UIKit.h&gt; #import &lt;Foundation/Foundation.h&gt;#endif","tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://blog.wenbobao.cn/tags/Xcode/"}]},{"title":"iOS获取当前网络的IP地址","date":"2014-04-10T03:41:11.000Z","path":"2014/04/10/iOS获取当前网络的IP地址/","text":"Objective code :、、、 (NSString )getIPAddress{NSString address = @”error”;struct ifaddrs interfaces = NULL;struct ifaddrs temp_addr = NULL;int success = 0; // retrieve the current interfaces - returns 0 on successsuccess = getifaddrs(&amp;interfaces);if (success == 0){// Loop through linked list of interfacestemp_addr = interfaces;while(temp_addr != NULL){if(temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET){// Check if interface is en0 which is the wifi connection on the iPhoneif([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@”en0”]){// Get NSString from C Stringaddress = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];}}temp_addr = temp_addr-&gt;ifa_next;}}// Free memoryfreeifaddrs(interfaces);return address;} 、、、","tags":[{"name":"IP Address","slug":"IP-Address","permalink":"http://blog.wenbobao.cn/tags/IP-Address/"}]},{"title":"Markdown 语法","date":"2014-03-09T03:41:11.000Z","path":"2014/03/09/Markdown语法/","text":"Markdown 优点: 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 标题这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。 而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。例如:123456# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 列表列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 - 就可以了，例如：123- 文本1- 文本2- 文本3 如果你希望有序列表，也可以在文字前面加上 1. 2. 3. 就可以了，例如:1231. 文本12. 文本23. 文本3 显示效果如下 : 文本1 文本2 文本3 注：- 和 1. 和文本之间要保留一个字符的空格。 链接和图片在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [显示文本](链接地址) 这样的语法即可，例如：1[简书](http://jianshu.io) 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 ![](图片链接地址) 这样的语法即可，例如：1![](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg) 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。 引用在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如：1&gt; 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 注：&gt; 和文本之间要保留一个字符的空格。 最终显示的就是: 一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 粗体和斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。例如:1*一盏灯*， 一片昏黄；**一简书**， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 最终显示的就是下文，其中「一盏灯」是斜体，「一简书」是粗体： 一盏灯， 一片昏黄；一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。 表格相关代码：12345| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 显示效果： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 相关代码:12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | baz 显示效果: dog bird cat foo foo foo bar bar bar baz baz baz 结语以上几种格式是比较常用的格式，所以我们针对这些语法做了比较详细的说明。除这些之外，Markdown 还有其他语法，如想了解和学习更多，可以参考这篇 Markdown 语法说明 强烈建议您现在就立马用 Markdown 写一篇文章吧，体会一下 Markdown 的优雅之处！","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://blog.wenbobao.cn/tags/Markdown/"}]}]